1.     Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.
 

Example 1:

Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.

answer:
class Solution:
    def hammingWeight(self, n: int) -> int:
        c=0
        if n==0:
            return 0
        while n:
            r=n%2
            n=n//2
            c=c+r
        return c
   ...............
 2.      A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Example 1:

Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

answer:
class Solution:
    def isHappy(self, n: int) -> bool:
        res=0
        while n:
            r=n%10
            n=n//10
            res+=pow(r,2)
            if n==0 and (res>=10 or res==7):
                print(res,end=" ")
                n=res
                res=0
        return res==1
 .....................
 3.     Example 1:

Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.

answer:
class Solution:
    def addDigits(self, num: int) -> int:
        s=0
        while num:
            r=num%10
            num=num//10
            s=s+r
            if num==0 and s>9:
                num=s
                s=0
        return s
   ......................
4.    MOVEZEROES
         Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

ANSWER:
 class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        i=0
        n=len(nums)
        for j in range(n):
            if nums[j]!=0:
                nums[i],nums[j]=nums[j],nums[i]
                i+=1
   ...................................
5.    Given an integer n, return true if it is a power of three. Otherwise, return false.

An integer n is a power of three, if there exists an integer x such that n == 3x.
Example 1:

Input: n = 27
Output: true
   ANSWRER:
   class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        p=0
        while True:
            if pow(3,p)==n:
                return True
            if pow(3,p)>n:
                return False
            p+=1
  .................................
6.   POWER OF FOUR
        Example 1:

Input: n = 16
Output: true
 ANSWER:
 class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        p=0
        while True:
            if pow(4,p)==n:
                return True
            if pow(4,p)>n:
                return False
            p+=1
  ..........................................
 7.693. Binary Number with Alternating Bit
Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.
Example 1:

Input: n = 5
Output: true
Explanation: The binary representation of 5 is: 101
   ANSWER:
   class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        d=n%2
        n=n//2
        while n:
            r=n%2
            n=n//2
            if d==r:
                return False
            d=r
        return True
 .......................................................
 8.     Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation.

Recall that the number of set bits an integer has is the number of 1's present when written in binary.

For example, 21 written in binary is 10101 which has 3 set bits.
 

Example 1:

Input: left = 6, right = 10
Output: 4
Explanation:
6 -> 110 (2 set bits, 2 is prime)
7 -> 111 (3 set bits, 3 is prime)
9 -> 1001 (2 set bits , 2 is prime)
10->1010 (2 set bits , 2 is prime)
  ANSWER:
  class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        def is_prime(n):
            if n==1:
                return False
            sq=int(math.sqrt(n))
            for i in range(2,sq+1):
                if n%i==0:
                    return False
            return True
        c=0
        for j in range(left,right+1):
            sbc=0
            while j:
                r=j%2
                j=j//2
                sbc=sbc+r
            c+=is_prime(sbc)
        return c
.................................................

   
   
   
   
   
   
   
   
   
   
   
   
   
        

